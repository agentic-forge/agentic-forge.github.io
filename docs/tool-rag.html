<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tool RAG - Agentic Forge</title>
    <meta name="description" content="Tool RAG provides dynamic tool selection using semantic search for better accuracy and token efficiency.">
    <link rel="icon" type="image/png" href="../assets/logo.png">
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <header>
        <div class="container header-content">
            <a href="../" class="logo">
                <img src="../assets/logo.png" alt="Agentic Forge Logo">
                Agentic<span>Forge</span>
            </a>
            <nav>
                <a href="../">Home</a>
                <a href="./" class="active">Docs</a>
                <a href="https://github.com/agentic-forge">GitHub</a>
            </nav>
        </div>
    </header>

    <main class="container">
        <div class="docs-layout">
            <aside class="docs-sidebar">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="./">Architecture</a></li>
                    <li><a href="./orchestrator.html">Orchestrator</a></li>
                    <li><a href="./armory.html">Armory</a></li>
                    <li><a href="./tool-rag.html" class="active">Tool RAG</a></li>
                    <li><a href="./interfaces.html">Interfaces</a></li>
                </ul>
            </aside>

            <article class="docs-content">
                <h1>Tool <span>RAG</span></h1>
                <p class="lead">
                    Dynamic tool selection using semantic search. Instead of loading all tools into context,
                    retrieve only the relevant ones for each query.
                </p>

                <h2>The Problem</h2>

                <h3>Context Bloat</h3>
                <p>
                    Each tool definition consumes tokens:
                </p>
<pre><code>Tool: get_weather
Description: Get current weather for a location...
Parameters:
  - location (string): The city name...
  - units (enum): celsius/fahrenheit...

≈ 50-100 tokens per tool</code></pre>
                <p>
                    With 50 tools = 2,500-5,000 tokens just for tool definitions.
                </p>

                <h3>Performance Degradation</h3>
                <p>
                    Research shows tool accuracy <strong>decreases</strong> as tool count increases:
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Tool Count</th>
                            <th>Success Rate</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>5 tools</td>
                            <td>95%</td>
                        </tr>
                        <tr>
                            <td>20 tools</td>
                            <td>85%</td>
                        </tr>
                        <tr>
                            <td>50 tools</td>
                            <td>70%</td>
                        </tr>
                        <tr>
                            <td>100+ tools</td>
                            <td>&lt;60%</td>
                        </tr>
                    </tbody>
                </table>

                <h2>The Solution</h2>

                <div class="architecture-diagram">
<pre>
┌─────────────┐
│ User Query  │
│ "Book a     │
│  flight to  │
│  Paris"     │
└──────┬──────┘
       │
       ▼
┌─────────────┐      ┌─────────────────────────────────────────┐
│   Embed     │      │           TOOL REGISTRY                  │
│   Query     │      │  book_flight    [0.2, 0.8, 0.1, ...]    │
└──────┬──────┘      │  get_weather    [0.5, 0.3, 0.7, ...]    │
       │             │  search_hotels  [0.3, 0.7, 0.2, ...]    │
       ▼             │              ... 1000s more ...          │
┌─────────────┐      └─────────────────────────────────────────┘
│  Semantic   │─────────────────────────────────────────────────>
│   Search    │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────────────────────────────┐
│  TOP-K RELEVANT TOOLS (k=5)                                  │
│  1. book_flight (0.95 similarity)                            │
│  2. search_flights (0.87 similarity)                         │
│  3. get_airport_info (0.72 similarity)                       │
└─────────────────────────────────────────────────────────────┘
       │
       ▼
┌─────────────┐
│    LLM      │  Only sees 5 tools instead of 1000+
│  (with 5    │  → Better accuracy
│   tools)    │  → Fewer tokens
└─────────────┘
</pre>
                </div>

                <h2>Benefits</h2>

                <p>Research from Red Hat and AWS shows:</p>
                <ul>
                    <li><strong>3x improvement</strong> in tool invocation accuracy</li>
                    <li><strong>~50% reduction</strong> in prompt token usage</li>
                    <li><strong>Scales to thousands</strong> of tools without degradation</li>
                </ul>

                <h2>How It Works</h2>

                <h3>1. Tool Registration</h3>
                <p>When tools are registered, their descriptions are embedded:</p>

<pre><code>async def register_tool(self, tool: ToolDefinition):
    # Generate embedding from description
    embedding = await self.embed(
        f"{tool.name}: {tool.description}"
    )

    # Store in vector index
    await self.index.upsert(
        id=tool.name,
        vector=embedding,
        metadata=tool.to_dict()
    )</code></pre>

                <h3>2. Query Processing</h3>
                <p>When a query comes in, embed it and search:</p>

<pre><code>async def search(self, query: str, top_k: int = 10):
    # Embed the query
    query_embedding = await self.embed(query)

    # Search vector index
    results = await self.index.search(
        query_embedding,
        top_k=top_k
    )

    # Return tool definitions
    return [r.metadata for r in results]</code></pre>

                <h3>3. Integration with Armory</h3>
                <p>Tool RAG integrates at the gateway level:</p>

<pre><code>class Armory:
    async def handle_tools_list(self, request):
        if self.tool_rag_enabled and request.context:
            # Return only relevant tools
            tools = await self.tool_rag.search(
                request.context,
                top_k=10
            )
        else:
            # Return all tools
            tools = await self.registry.list_all()

        return tools</code></pre>

                <h2>Embedding Strategies</h2>

                <table>
                    <thead>
                        <tr>
                            <th>Strategy</th>
                            <th>What to Embed</th>
                            <th>Pros/Cons</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Description only</td>
                            <td>Tool description text</td>
                            <td>Simple, may miss nuance</td>
                        </tr>
                        <tr>
                            <td>Description + params</td>
                            <td>Description + parameter names</td>
                            <td>More context, better matching</td>
                        </tr>
                        <tr>
                            <td>Synthetic queries</td>
                            <td>Generated example queries</td>
                            <td>Best accuracy, more compute</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Embedding Models</h2>

                <table>
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Dimensions</th>
                            <th>Speed</th>
                            <th>Cost</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>text-embedding-3-small</td>
                            <td>1536</td>
                            <td>Fast</td>
                            <td>$0.02/1M tokens</td>
                        </tr>
                        <tr>
                            <td>text-embedding-3-large</td>
                            <td>3072</td>
                            <td>Medium</td>
                            <td>$0.13/1M tokens</td>
                        </tr>
                        <tr>
                            <td>all-MiniLM-L6-v2 (local)</td>
                            <td>384</td>
                            <td>Very Fast</td>
                            <td>Free</td>
                        </tr>
                        <tr>
                            <td>BGE-large (local)</td>
                            <td>1024</td>
                            <td>Medium</td>
                            <td>Free</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Configuration</h2>

<pre><code># In armory.yaml
tool_rag:
  enabled: true
  embedding_model: "text-embedding-3-small"
  default_top_k: 10
  similarity_threshold: 0.5  # Filter low-relevance matches
  cache_embeddings: true     # Cache query embeddings</code></pre>

                <h2>Metrics</h2>

<pre><code>class ToolRAGMetrics:
    def recall_at_k(self, query, expected_tools, k):
        """What % of needed tools were retrieved?"""
        retrieved = self.search(query, top_k=k)
        return len(set(retrieved) & set(expected_tools)) / len(expected_tools)

    def precision_at_k(self, query, expected_tools, k):
        """What % of retrieved tools were actually needed?"""
        retrieved = self.search(query, top_k=k)
        return len(set(retrieved) & set(expected_tools)) / len(retrieved)

    def mrr(self, query, expected_tool):
        """Mean Reciprocal Rank - how early does the right tool appear?"""
        retrieved = self.search(query, top_k=20)
        for i, tool in enumerate(retrieved):
            if tool == expected_tool:
                return 1.0 / (i + 1)
        return 0.0</code></pre>

                <h2>References</h2>
                <ul>
                    <li><a href="https://next.redhat.com/2025/11/26/tool-rag-the-next-breakthrough-in-scalable-ai-agents/">Tool RAG: The Next Breakthrough (Red Hat)</a></li>
                    <li><a href="https://arxiv.org/html/2509.20386">Dynamic ReAct Paper</a></li>
                    <li><a href="https://builder.aws.com/content/2zeKrP0DJJLqC0Q9jp842IPxLMm/">AWS Strands SDK - Dynamic Tool Loading</a></li>
                </ul>
            </article>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>Agentic Forge &copy; 2025 &middot; <a href="https://github.com/agentic-forge">GitHub</a></p>
        </div>
    </footer>
</body>
</html>
